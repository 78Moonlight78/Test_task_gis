# Тестовое задание 
### Задание №1.«Дубликаты»
В задании не указанно вводятся ли символы с клавиатуры или хронятся в переменной, поэтому есть два варианта решения.Файл ***1_1.cs - ввод с клавиатуры*** элементов массива. ***1_2.cs - перебираемый массив хронится в переменной***.     
Так как в задание не указанно ограничение по времени и ограничение входных данных, то буду использовать один из самых оптимальных решений на мой взгляд: создание Dictionary для хранения дубликатов, а также их количества. Временная сложность при использовании данного алгоритма будет O(n), а емкостная сложность будет O(n). Если количетсов элементов в массиве было бы достаточно большим, то было бы логично использовать сортировку и бинарный поиск для решния задачи( временная сложность такого алгоритма O(n logn))
### Задание №2 «SQL»
SQL запрос представлен в файле 2.sql.
#### Ответ на вопрос: Чем будет отличаться SQL-запрос, если указанные данные будут храниться в СУБД Oracle?
В целом, SQL-запрос для Oracle будет очень похож на запрос для PostgreSQL. Основные отличия будут незначительными, и в данном конкретном случае - практически отсутствуют, если учитывать, что имена таблиц и столбцов в исходном запросе были указаны с учетом регистра.
### Задание №3 «Bash»
сскрипт распаложен в файле 3   
Пояснение:    
1.#!/bin/bash: Shebang, указывающий, что скрипт нужно выполнять с помощью bash.

Получение информации:
1. USERNAME=$(whoami): Определяет имя текущего пользователя.
2. HOSTNAME=$(hostname): Определяет имя хоста (имя компьютера).
3. CURRENT_DATE=$(date "+%Y-%m-%d %H:%M:%S"): Получает текущую дату и время в формате ГГГГ-ММ-ДД ЧЧ:ММ:СС.
4.  uptime: Выводит информацию о времени работы системы.
5. KERNEL_INFO=$(uname -sr): uname -sr: Выводит название ядра операционной системы и версию ядра.
6. LOGGED_IN_USERS=$(w | awk 'NR>2 {print $1}'):
> w: Выводит информацию о подключенных пользователях.      
> awk 'NR>2 {print $1}': Извлекает имя пользователя из каждой строки вывода w, начиная со строки номер 3 (чтобы исключить заголовки).     
7. LOAD_AVERAGE=$(uptime | awk -F 'average:' '{print $2}' | sed 's/ //g'):
> uptime: Выводит информацию о времени работы системы и средней загрузке.   
> awk -F 'average:' '{print $2}': Разделяет вывод uptime на поля, используя “average:” как разделитель и выводит второе поле, которое содержит среднюю загрузку.   
> sed 's/ //g': Удаляет все пробелы из полученной строки.    

